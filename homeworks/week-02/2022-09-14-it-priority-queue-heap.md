---
title: "[자료구조] 우선순위 큐와 힙"
author: dapin1490
date: 2022-09-14T21:13:00+09:00
categories: [지식, IT]
tags: [지식, IT, 자료구조, 우선순위 큐, 힙, 과제]
render_with_liquid: false
---

## 과제 문제
`우선순위 큐와 힙 내용 정리, C++를 이용한 우선순위큐 프로그래밍 방법 정리(준비중)`  
  
## 우선순위 큐 : 정렬된 큐  
  
힙 heap : 트리의 형태로 표현됨.  
  
트리 : 사이클이 없는 그래프. [참고](https://dapin1490.github.io/satinbower/posts/it-data-structure-tree/)  
이진 트리 binary tree : 모든 노드가 두 개 이하의 자식을 가지는 트리.  
포화 이진 트리 : 단말 노드를 제외한 모든 노드가 두 개의 자식을 가지는 트리.  
완전 이진 트리 : 마지막 레벨을 제외한 모든 레벨에 노드가 완전히 채워져 있고, 마지막 레벨에서는 왼쪽부터 차례로 노드가 채워진 트리.  
거의 완전 이진 트리 nearly complete- : 마지막 레벨에서 노드가 왼쪽부터 채워지되, 한 노드가 자식 노드를 하나만 갖는 트리.  
  
힙의 구성 조건  
- 거의 완전 이진 트리일 것
- 부모의 키가 자식의 키보다 크거나 같아야 함(루트가 최댓값을 가짐, max heap)
- 부모의 키가 자식의 키보다 작거나 같은 힙은 min heap
- 같은 부모 아래의 자식 노드의 정렬은 고려하지 않는다.
  
<br>
  
우선순위 큐에서 사용할 기능
- `insert(S, x)` : 새 요소 삽입
- `max(S)` : 최댓값 보기
- `extract_max(S)` : 최댓값 꺼내기
- `increase_key(S, x, k)` : 설명 제대로 못 들었음. 요소 x의 키 값을 k 증가.
  
<br>
  
우선순위 큐를 배열로 구현할 때 계산의 편의성을 위해 **0번 인덱스는 무시**한다.
  
## 배열 다루기
- root : 첫 요소
- parent(i) = `i / 2`
- left(i) = `i * 2`, right(i) = `i * 2 + 1`
- `build_max_heap` : 어떤 배열 전체를 최대 힙으로 바꿔주는 것
- `max_heapify` : 특정 인덱스에 대한 서브트리를 최대 힙 조건을 만족하도록 바꾸는 것.
  
`max_heapify`
- 전제 : 주어진 인덱스의 자식노드를 루트로 하는 서브트리는 각각 힙 성질을 만족한다고 본다.
- 만약 주어진 인덱스의 요소와 그 자식 노드가 힙 성질을 만족하지 않는다면 두 자식 중 큰 쪽과 부모를 바꾼다.
- 만약 바꿨다면 교환한 자식 노드에 대해 다시 `max_heapify`를 호출한다.
  
`build_max_heap(A)`
- 주어진 배열 A를 최대 힙으로 바꾼다
- ```cpp
  for i=n/2 downto 1
    do max heapify(i)
  ```
- `i`가 `n/2`부터 시작하는 이유 : 인덱스가 가장 작은 리프노드가 `2/n + 1`부터 시작하고, 리프노드는 정렬할 필요가 없으니 리프노드 앞에서부터 시작.

<br>

## 힙 정렬
1. build max heap
2. find max A[1]
3. swap A[1] & A[n]
4. discard node n
5. run `max_heapify`
6. goto step 2, until empty

**주의**  
2번 과정에서 최댓값을 찾아낸 후, 배열에 남은 값을 한 칸씩 앞으로 당기지 않는다. 그렇게 한다고 해서 새로 만들어진 힙이 힙 성질을 만족한다고 보장할 수 없다.  
그렇기 때문에 배열의 마지막에 있는 값을 가져온다.