## big-o
- Algorithm Usage
- 시간과 컴퓨터 성능에 독립적
- 입력의 크기(n)에 따라 달라짐
- 최악의 경우를 상정하나, 식은 가능한 타이트하게 잡는다. 예) 어디 살아요? 지구에 살아요(X) ㅁㅁ시에 살아요(O)
  
### O(1)
어떤 입력이 들어와도 무조건 같은 횟수의 연산을 함  
  
### O(log<sub>2</sub>n)
입력 사이즈가 커질 때 초반에는 빠르게 상승하는 경향을 보이나 그 상승폭이 갈수록 줄어듦. 컴퓨터 사이언스에서 로그는 기본적으로 밑을 2로 갖는다.  
  
### O(n)
선형 증가. 입력의 모든 요소를 한번씩 확인해야 하는 경우. 예를 들면 정렬되지 않은 배열에서 최댓값 찾기, 배열의 모든 요소의 합 구하기 등. 여기까지만 해도 준수한 알고리즘임.  
  
### O(nlogn)
여기까지도 괜찮은 알고리즘  
  
### O(n<sup>2</sup>)
갈수록 상승폭이 커지기 때문에 안 좋은 알고리즘  
  
### O(2<sup>n</sup>)
처음부터 발산하기 때문에 쓰면 안 된다.  
  
### 예제
- O(1) + O(1) == O(1) 참
- O(3n<sup>2</sup>) == O(1/2n<sup>2</sup>) 참
  
### 힙 삽입 연산의 big-o
- 레벨(h) 3, 노드(n) 6개 있는 힙에 새 요소 추가하기
  최선의 경우 : 어떠한 교환 연산도 일어나지 않음 → O(1)
  최악의 경우 : 새 노드가 루트까지 교환됨 → O(h)
  노드의 개수 n은 (2<sup>h</sup> - 1)로 나타낼 수 있다. 고로 O(logn)이다.

### 피보나치 수열의 big-o
재귀로 구현한다면 O(2<sup>n</sup>)이지만 이건 loose bound이고, 잘만 하면 이것보다는 낫다는 것을 증명한 사람이 있다. 그건 알아서 찾아보라.
