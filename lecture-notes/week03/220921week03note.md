## big-o
- Algorithm Usage
- 시간과 컴퓨터 성능에 독립적
- 입력의 크기(n)에 따라 달라짐
- 최악의 경우를 상정하나, 식은 가능한 타이트하게 잡는다. 예) 어디 살아요? 지구에 살아요(X) ㅁㅁ시에 살아요(O)
  
### O(1)
어떤 입력이 들어와도 무조건 같은 횟수의 연산을 함  
  
### O(log<sub>2</sub>n)
입력 사이즈가 커질 때 초반에는 빠르게 상승하는 경향을 보이나 그 상승폭이 갈수록 줄어듦. 컴퓨터 사이언스에서 로그는 기본적으로 밑을 2로 갖는다.  
  
### O(n)
선형 증가. 입력의 모든 요소를 한번씩 확인해야 하는 경우. 예를 들면 정렬되지 않은 배열에서 최댓값 찾기, 배열의 모든 요소의 합 구하기 등. 여기까지만 해도 준수한 알고리즘임.  
  
### O(nlogn)
여기까지도 괜찮은 알고리즘  
  
### O(n<sup>2</sup>)
갈수록 상승폭이 커지기 때문에 안 좋은 알고리즘  
  
### O(2<sup>n</sup>)
처음부터 발산하기 때문에 쓰면 안 된다.  
  
### 예제
- O(1) + O(1) == O(1) 참
- O(3n<sup>2</sup>) == O(1/2n<sup>2</sup>) 참
  
#### 힙 삽입 연산의 big-o  
- 레벨(h) 3, 노드(n) 6개 있는 힙에 새 요소 추가하기
  최선의 경우 : 어떠한 교환 연산도 일어나지 않음 → O(1)
  최악의 경우 : 새 노드가 루트까지 교환됨 → O(h)
  노드의 개수 n은 (2<sup>h</sup> - 1)로 나타낼 수 있다. 고로 O(logn)이다.

#### 피보나치 수열의 big-o  
재귀로 구현한다면 O(2<sup>n</sup>)이지만 이건 loose bound이고, 잘만 하면 이것보다는 낫다는 것을 증명한 사람이 있다. 그건 알아서 찾아보라.
  
#### 오븐  
1. 오븐 1개 예약받기
2. 예약 → 오븐에 넣는 시간 t 결정
3. k 시간 예약 없으면 t ∊ R
4. 다 구우면 Extraction
  
계산의 편의를 위해 `k = 2`라고 가정하자. 현재 예약된 시간은 `2, 6, 8, 12, 17, 19, 23`  
현재 예약된 시간의 집합은 R, big-o는 O(logn)으로 하고 싶다. 어떻게 할 수 있을까?  
  
- 방법  
  
<ol>
  <li>unsorted array : O(n)</li>
  <li>sorted array : O(n)
    <ol>
      <li>search : O(logn)</li>
      <li>compare : O(1)</li>
      <li>insert : 삽입하려면 전부 자리를 하나씩 움직여야 하므로 O(n) → 이게 문제</li>
    </ol>
  </li>
  <li>(linked) list
    <ol>
      <li>search : O(n) → 삽입 연산은 간단하지만 이게 문제</li>
    </ol>
  </li>
  <li>heap<br>
    힙은 weekly invariant하기 때문에 삽입해도 되는지 검증하려면 모든 노드를 방문해야 한다. 고로 O(n)
  </li>
</ol>
  
- 제안  
  정렬된 배열의 탐색과 비교 연산, 힙의 삽입 연산을 합치면 O(logn)이 될 수 있다. → 서브트리의 좌우 크기까지 정렬하는 이진 탐색 트리를 쓴다.  
  탐색의 방향이 정해져 있고(탐색 O(h) == O(logn)), 삽입도 간단하니 모든 과정을 합해 O(logn) 가능?  
  
- 문제  
  이진 탐색 트리의 루트 노드는 어떻게 정하나? 잘못 정하면 리스트와 다를 게 없어진다. 높이를 최소화해야 한다.  
  
- 해결  
  양쪽 서브트리의 높이 차이를 1 이하로 유지한다.

<br>

## 이진 탐색 트리
- 문제  
  서치는 간단하다. 그런데 만약 특정 값보다 작거나 큰 값의 개수를 세고 싶다면?  
  
- 해결  
  각 노드에 자기 자신을 포함한 자손 노드의 개수를 같이 저장한다.  
  원하는 값을 찾을 때까지 내려가면서 (1) 자기 자신보다 작거나 같으면 or 크거나 같으면 +1, (2) 해당 노드의 왼쪽 or 오른쪽 자손 노드의 개수도 더한다. 원하는 노드를 찾으면 해당 노드의 개수를 세고 끝낸다.
