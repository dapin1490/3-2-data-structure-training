## 프로젝트 설명
평가 요소 : 내 데이터가 얼마나 많이 쓰였고, 내가 다른 사람들의 데이터를 얼마나 많이 썼는가.  
주의 : 쓰레기 줍는다고 함부로 위험한 데 들어가지 말고, 사진 찍는다고 쓰레기 던지는 건 되는데 던진 건 다시 주워와라.  
발표 : annotation(뭔지 모름) 생략, 발표 자료는 pdf로 lms에 업로드, 분량 제한 3페이지. 사진은 다른 사람이 가져가기 쉬운 방식으로 공유할 것. 발표 도중 다과 가능.  
사진 : 보통 폰으로 사진을 찍으면 3024&#42;4032 크기로 찍힐 텐데 보통은 작은 사진을 많이 사용한다. 줄이는 건 알아서 하라. 자신의 자료를 이용하는 방법에 대한 매뉴얼을 올리고 싶으면 발표자료랑 따로 올려도 됨.  
프로젝트 : 문제부터 각자 정의하고 시작한다. 중간 발표에서는 자신이 어떤 문제를 정의했는지, 어떻게 풀고 싶은지 발표하면 된다. 결과물은 기말 발표에서 보여주면 된다. 중간 발표 이후에 새로운 알고리즘들을 배울 것이니 중간 발표 이후 내용을 바꿔도 좋다. 바꾼 부분만 언급하면 된다.  
예 : 여기저기 퍼진 쓰레기를 최단거리로 모두 순회하여 수거하는 알고리즘, 유리만 골라서 수거하는 최단거리 알고리즘 등등  
사진 좌표 : 구글 지도에서 대충 이쯤이었다 하고 찍어도 됨.
  
---  
  
## 배운 내용 리뷰
트리는 사이클이 없는 그래프. 각 노드는 간선으로 연결됨. 각 노드가 두 개 이하의 자식을 가지면 이진 트리.  
힙 트리 : 시각적으로만 트리이고 배열로 구현 가능. 거의 완전한 이진트리라서 가능했음.  
교수님이 말하는 스케줄링 문제 : 내 달력에 끼워넣을 수 있는 일정 판단하기.  
BST는 스케줄링 문제에 좋다.  
BST : 오른쪽이 항상 왼쪽보다 같거나 크다(max heap)/작다(min heap).  
BST에서 특정 지점 이후/이전 요소 개수 세기 : 배열로 구현하면 인덱스가 있으니 쉽게 찾을 수 있지만 BST는 트리이기 때문에 그게 어렵다.  
이를 보완하기 위해 `data structures augmentation`을 한다. 각 노드에 자신을 포함한 자손 노드의 수를 표기한다. 이런 문제를 푸는 것을 Rank(t)라고 한다.  
```txt
서브트리를 이용한 어그멘테이션
문제 : 특정 값보다 작거나 같은 값의 개수 세기
1. 찾는 값이 나올 때까지 탐색
2. 찾는 값보다 작거나 같은 것이 나오면 +1, 왼쪽 서브트리의 개수도 더한다.
```  
다른 방법 : AVL height를 이용한 어그멘테이션  

---

| 연산 | 힙 | BST |
|-----|-----|-----
| 삽입 | 로그엔 | 로그h |
| 삭제 | 로그엔 | 로그h |
| 이상/이하 | 엔 | 로그h |

---

BST는 높이를 줄일수록 연산이 효율적이게 된다. 높이를 줄이려면 모든 노드가 최대한의 자식을 갖도록 하면 된다. 이를 밸런스가 잡혀 있다고 하며 AVL 트리라고 부른다. 모든 노드의 좌우 자식 높이 차이가 최대 1이어야 한다.  
각 노드에서의 높이란 해당 노드에서 리프까지 가는 길이를 말한다. 고로 리프노드는 자신이 리프이므로 높이가 0, 리프의 부모 노드는 1, 루트 노드는 h - 1이다. 모든 노드의 좌우 자식 높이 차이가 최대 1이어야 한다는 것은 이 높이의 차이를 의미한다.  
AVL 트리 : BST의 성질을 모두 갖는다. 그리고 밸런스가 잡혀 있다.  
  
AVL 트리의 최선과 최악  
최선은 쉽다. 최악은 왼쪽 맨 아래 루트부터 시작해서 레벨 하나 차이만 나게 최소한의 노드를 채우면서 층을 올리면 된다.

---

AVL 트리 : 모든 노드 왼쪽 자식 높이 + 1 == 오른쪽 자식 높이  
N<sub>h</sub> : 높이 h의 AVL 트리 노드 최소 갯수  
N<sub>h</sub> = N<sub>h-1</sub> + N<sub>h-2</sub> + 1 > F<sub>h</sub> = F<sub>h-1</sub> + F<sub>h-2</sub>(피보나치 수열)  
N<sub>h</sub> > F<sub>h</sub>  
n > F<sub>h</sub> -> 어떤 상수에 대해 h가 지수로 들어가는 지수식으로 치환됨  
양변에 로그  
log<sub>상수</sub>n > h...  
대략 1.414logn > h 정도로 정리됨  
  
<br>

N<sub>h</sub> = N<sub>h-1</sub> + N<sub>h-2</sub> + 1 > 1 + 2N<sub>h-2</sub>  
N<sub>h</sub> = N<sub>h-1</sub> + N<sub>h-2</sub> + 1 > 2N<sub>h-2</sub>  
아까와 같이 지수로 바꾸고 양변에 로그 하면서 정리하면 위와 비슷한 식이 됨.  
  
---

AVL 트리 만들기
1. BST insert를 그대로 함
2. 밸런스가 맞을 수도 있고 아닐 수도 있다 -> 넣은 후 고친다
3. 고치는 방법 : 균형이 맞지 않는 부분의 트리를 회전한다. 예를 들어 23<-24<-29 서브트리를 23<-24->29로 돌리는 것. 이 경우 루트를 기준으로 오른쪽으로 돌렸기 때문에 right 로테이션이라고 한다. 다른 예를 들어 55<-50<-67처럼 지그재그로 있는 경우에는 오른쪽으로 돌리면 성질을 위배하기 때문에 돌릴 수 없다. 그러므로 아래의 두 노드를 먼저 바꾼 후 오른쪽으로 돌린다. 50<-55<-67 이후 50<-55->67로 바꾼다. 이것은 두 번 바꾸기 때문에 투 로테이션/더블 로테이션 등으로 부른다.
  고치는 과정은 포인터만 바꾸면 되기 때문에 O(1)이다.  
  
다른 예시는 타이핑하기가 힘들어서 그림으로 그림
